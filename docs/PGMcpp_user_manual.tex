\documentclass[12pt, letterpaper]{report}

% Package uses
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage[all]{nowidow}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[dvipsnames]{xcolor}
\usepackage{cite}
\usepackage{fancyvrb}
\usepackage{graphicx}
	\graphicspath{ {images} }
\usepackage{lscape}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[margin = 1in]{geometry}
\usepackage{pythonhighlight}
\usepackage{minted}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{titlesec}

\frenchspacing

\renewcommand{\bibname}{References}

%\renewcommand\thechapter{}
\renewcommand{\chaptername}{}

\begin{document}


% ----- TITLE PAGE -----

\begin{titlepage}
	\vspace*{\stretch{0.5}}
	\begin{center}
		\Large \textbf{User Manual} \\
        \large \textbf{PGMcpp : PRIMED Grid Modelling Code (in C++) - v2.1} \\
	\end{center}
	\vfill
	\begin{center}
		\today \\
		\vspace{3mm}
		Drafted using \LaTeX
	\end{center}	   
\end{titlepage}


% ----- FRONT MATTER -----

\pagenumbering{roman}

\addcontentsline{toc}{chapter}{License}
\chapter*{License}

\begin{footnotesize}
    \begin{verbatim}
        PGMcpp : PRIMED Grid Modelling Code (in C++) - v2.1
        Copyright 2023 (C)
        
        Anthony Truelove MASc, P.Eng.
        email:  gears1763@tutanota.com
        github: gears1763-2
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
        1. Redistributions of source code must retain the above copyright notice,
        this list of conditions and the following disclaimer.
        2. Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.
        3. Neither the name of the copyright holder nor the names of its contributors
        may be used to endorse or promote products derived from this software without
        specific prior written permission.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
        LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
        SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
        ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        POSSIBILITY OF SUCH DAMAGE.
        
        CONTINUED USE OF THIS SOFTWARE CONSTITUTES ACCEPTANCE OF THESE TERMS.
        
        *** EXCEPTION ***: This license does not apply to the contents of /third_party. The
        contents of that directory are covered by their own, included licenses. See those
        licenses for terms and conditions pertaining to that code.
    \end{verbatim}
\end{footnotesize}


\tableofcontents
\addcontentsline{toc}{chapter}{Contents}

\listoftables
\addcontentsline{toc}{chapter}{List of Tables}

%\listoffigures
%\addcontentsline{toc}{chapter}{List of Figures}

\newpage 
\pagenumbering{arabic}
\chapter{Introduction}

The intent of PGMcpp is to provide a general purpose code base for the modelling and simulation of microgrids, with the particular goal of assessing the economic and environmental impacts of integrating renewable energy generation and energy storage assets over some project life. It is designed to be open and extensible, so that the researcher can modify it to suit their individual needs.\par 
This user manual will go over the features of PGMcpp, including the various classes that make up the code base, and will conclude with a treatment of dispatch control and the presentation of an example project.

\chapter{The \texttt{Model} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/Model.h}\par
\noindent\underline{Source}:\quad\texttt{source/Model.cpp}\par
\end{large}
\vspace{5mm}

The central class of PGMcpp is the \texttt{Model} class, which is designed to act as a container class for the electrical demand data, renewable resource data, various production and storage assets, and dispatch control strategies.

\section{Attributes}

Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Model} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structModel {
        bool print_flag = false;
        bool test_flag = false;
        
        DispatchMode dispatch_mode = LOAD_FOLLOWING_IN_ORDER;
        
        double nominal_inflation_rate_annual = 0.02;
        double nominal_discount_rate_annual = 0.04;
        
        std::string path_2_load_data = "";
    };
\end{verbatim}

\newpage
\noindent Each attribute of \texttt{structModel} is described below in Table \ref{tab:structModel_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structModel} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{print\_flag} & {boolean} & {false} & {Controls whether or not running prints are done.} \\\hline
        \texttt{test\_flag} & {boolean} & {false} & {Toggles testing printouts.} \\\hline
        \texttt{dispatch\_mode} & {DispatchMode} & {LOAD\_FOLLOWING\_IN\_ORDER} & {Defines which dispatch control mode to use during a \texttt{Model} run. More on this later.} \\\hline
        \texttt{nominal\_inflation\_rate} & {double} & {0.02} & {The nominal inflation rate (annual) to be applied to the entire model.} \\\hline
        \texttt{nominal\_discount\_rate} & {double} & {0.04} & {The nominal discount rate (annual) to be applied to the entire model.} \\\hline
        \texttt{path\_2\_load\_data} & {string} & {empty} & {The (relative) path to the file containing the intended electrical load data (time series).} \\\hline
    \end{tabular}
    }
    \label{tab:structModel_attributes}
\end{table}

\noindent Note that these structured attributes are the only \texttt{Model} attributes which are intended to be modified by the user; all other attributes of the class (while nonetheless public) are not intended to be modified by the user \textit{under normal execution}. That said, all attributes are, of course, intended to be read by the user.\par 
The complete set of \texttt{Model} attributes is described below in Table \ref{tab:Model_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Model} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{struct\_model} & {structModel} & {as laid out in Table \ref{tab:structModel_attributes}} & {The structure of inputs required by the \texttt{Model} class constructor.} \\\hline
        \texttt{n\_timesteps} & {integer} & {8760} & {The number of time steps over which the model will run (inferred during construction).} \\\hline
        \texttt{project\_life\_yrs} & {double} & {0} & {The project life, in years, to be modelled (inferred during construction).} \\\hline
        \texttt{total\_load\_served\_kWh} & {double} & {0} & {The total load (energy) served during a model run, expressed in kiloWatt-hours.} \\\hline
        \texttt{total\_fuel\_consumed\_L} & {double} & {0} & {The total volume of fuel consumed during a model run, expressed in litres.} \\\hline
        \texttt{total\_CO2\_emitted\_kg} & {double} & {0} & {The total mass of carbon dioxide emitted during a model run, expressed in kilograms.} \\\hline
        \texttt{total\_CO\_emitted\_kg} & {double} & {0} & {The total mass of carbon monoxide emitted during a model run, expressed in kilograms.} \\\hline
        \texttt{total\_NOx\_emitted\_kg} & {double} & {0} & {The total mass of nitrogen oxides emitted during a model run, expressed in kilograms.} \\\hline
        \texttt{total\_SOx\_emitted\_kg} & {double} & {0} & {The total mass of sulfur oxides emitted during a model run, expressed in kilograms.} \\\hline
        \texttt{total\_CH4\_emitted\_kg} & {double} & {0} & {The total mass of methane emitted during a model run, expressed in kilograms.} \\\hline
        \texttt{total\_PM\_emitted\_kg} & {double} & {0} & {The total mass of particulate matter emitted during a model run, expressed in kilograms.} \\\hline
        \texttt{real\_discount\_rate\_annual} & {double} & {0} & {The real discount rate (annual) to be applied to the entire model (computed from the given nominal inflation and discount rates).} \\\hline
        \texttt{net\_present\_cost} & {double} & {0} & {The net present cost of the system, as computed following a model run. The units of currency are left undefined.} \\\hline
        \texttt{levellized\_cost\_of\_energy\_per\_kWh} & {double} & {0} & {The levellized cost of energy (per kiloWatt-hour served), as computed following a model run. The units of currency are left undefined.} \\\hline
        \texttt{dt\_vec\_hr} & {vector of doubles} & {empty} & {A sequence of time deltas, expressed in hours (inferred during construction).} \\\hline
    \end{tabular}
    }
    \label{tab:Model_attributes}
\end{table}

\begin{center}
    \scalebox{0.8}{
    \begin{tabular}{|c|p{0.33\textwidth}|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{load\_vec\_kW} & {vector of doubles} & {empty} & {A sequence of load values, expressed in kiloWatt-hours. This is read from the given load data.} \\\hline
        \texttt{net\_load\_vec\_kW} & {vector of doubles} & {empty} & {A sequence of net load values, expressed in kiloWatt-hours. The net load over a given time step is the load minus all renewable production, and so this attribute is computed as part of a model run.} \\\hline
        \texttt{remaining\_load\_vec\_kW} & {vector of doubles} & {empty} & {A sequence of remaining load values, expressed in kiloWatt-hours, which are computed are part of a model. If any load is left unsatisfied by the grid design, it is recorded here.} \\\hline
        \texttt{time\_vec\_hr} & {vector of doubles} & {empty} & {A sequence of time values (from time = 0, taken to be the start of the project), expressed in hours. This is read in from the given load data.} \\\hline
        \texttt{resource\_map\_1D} & {map of (integer, vector of doubles) pairs} & {empty} & {A map containing the various one-dimensional renewable resources in play. This map is populated from data provided by the user.} \\\hline
        \texttt{resource\_path\_map\_1D} & {map of (integer, string) pairs} & {empty} & {A map containing the paths to the one-dimensional resource data provided by the user.} \\\hline
        \texttt{resource\_map\_2D} & {map of (integer, vector of vectors of doubles) pairs} & {empty} & {A map containing the various two-dimensional renewable resources in play. This map is populated from data provided by the user.} \\\hline
        \texttt{resource\_path\_map\_2D} & {map of (integer, string) pairs} & {empty} & {A map containing the paths to the two-dimensional resource data provided by the user.} \\\hline
        \texttt{nondisp\_ptr\_vec} & {vector of pointers to Nondispatchable} & {empty} & {A vector containing pointers to the various Nondispatchable assets added to the model.} \\\hline
        \texttt{combustion\_ptr\_vec} & {vector of pointers to Combustion} & {empty} & {A vector containing pointers to the various Combustion (Dispatchable) assets added to the model.} \\\hline
        \texttt{noncombustion\_ptr\_vec} & {vector of pointers to Dispatchable} & {empty} & {A vector containing pointers to the various non-Combustion (Dispatchable) assets added to the model.} \\\hline
        \texttt{storage\_ptr\_vec} & {vector of pointers to Storage} & {empty} & {A vector containing pointers to the various Storage assets added to the model.} \\\hline
    \end{tabular}
    }
\end{center}

It is important to understand one of the key modelling constraints built into PGMcpp. That is, \textit{all time series are taken to be commensurate with the given load data}. That is, every time series is required to be associated with the same \texttt{time\_vec\_hr}, so all input data must be prepared accordingly (and this is checked for and enforced by the model!). However, having satisfied that constraint, one can make the time series data as short or as long as desired. Furthermore, the time series need not be uniform (that is, the time deltas can vary throughout the time series).

\section{Methods}

The \texttt{Model} class has a number of helper methods (denoted by the leading \_ in the method name) which are not intended to be called directly (that is, they do not make up part of the intended user interface). You can learn more about these methods by reviewing the header and source files for \texttt{Model}. In this section, the methods that make up the intended user interface are presented, as these methods are the only ones the user should need to work with \textit{under normal execution}.

\subsection{\texttt{Model(\;\;)} (Constructor)}

\begin{verbatim}
    Model :: Model(structModel struct_model)
\end{verbatim}

This is the constructor for the \texttt{Model} class, and it expects a \texttt{structModel} instance as its sole argument. A minimal working example of invoking the class constructor is as follows

\begin{verbatim}
    structModel model_inputs;
    model_inputs.path_2_load_data =
        "data/input/test/electrical_load_generic_peak-500kW_1yr_dt-1hr.csv";

    Model model(model_inputs);
\end{verbatim}

\noindent The user must provide a valid (relative) path to electrical load data at construction, and the load data must have the expected format. For an example of the expected format, see

\begin{verbatim}
    data/input/test/electrical_load_generic_peak-500kW_1yr_dt-1hr.csv
\end{verbatim}

\subsection{\texttt{add1dRenewableResource(\;\;)}}

\begin{verbatim}
    void Model :: add1dRenewableResource(
        std::string type_str,
        std::string path_2_resource_data,
        int map_key
    )
\end{verbatim}

This method loads a one-dimensional renewable resource into an existing \texttt{Model} instance, where ``one-dimensional renewable resource" means a time series of scalar resource values (i.e., one value per point in time). It expects three arguments

\begin{enumerate}
    \item \texttt{std::string type\_str}, a string denoting the resource type (i.e., solar, wind, tidal, etc.). This argument is not case sensitive, but it is sensitive to spelling.
    \item \texttt{std::string path\_2\_resource\_data}, a string denoting the (relative) path to the appropriate one-dimensional resource time series.
    \item \texttt{int map\_key}, an integer that forms the key part of a (key, value) pair. This is the key used when inserting the given data and path into \texttt{resource\_map\_1D} and \texttt{resource\_path\_map\_1D}, respectively.
\end{enumerate}

\noindent A minimal working example of invoking this method is as follows (e.g., adding a time series of solar resource)

\begin{verbatim}
    int solar_resource_key = 1;
    
    model.add1dRenewableResource(
        "solar",
        "data/input/test/solar_GHI_peak-1kWm2_1yr_dt-1hr.csv",
        solar_resource_key
    );
\end{verbatim}

\noindent The user must provide a valid (relative) path to resource data, and the data must have the expected format. For examples of the expected format, see the example resource files provided in

\begin{verbatim}
    data/input/test/
\end{verbatim}

\noindent Finally, if the user re-uses the same map key argument in successive calls to this method, then the corresponding contents of the one-dimensional resource maps are overwritten on each call (this will generate a warning).

\subsection{\texttt{add2dRenewableResource(\;\;)}}

\begin{verbatim}
    void Model :: add2dRenewableResource(
        std::string type_str,
        std::string path_2_resource_data,
        int map_key
    )
\end{verbatim}

This method loads a two-dimensional renewable resource into an existing \texttt{Model} instance, where ``two-dimensional renewable resource" means a time series of vector resource values (i.e., two values per point in time). It expects three arguments

\begin{enumerate}
    \item \texttt{std::string type\_str}, a string denoting the resource type (i.e., wave). This argument is not case sensitive, but it is sensitive to spelling.
    \item \texttt{std::string path\_2\_resource\_data}, a string denoting the (relative) path to the appropriate two-dimensional resource time series.
    \item \texttt{int map\_key}, an integer that forms the key part of a (key, value) pair. This is the key used when inserting the given data and path into \texttt{resource\_map\_2D} and \texttt{resource\_path\_map\_2D}, respectively.
\end{enumerate}

\noindent A minimal working example of invoking this method is as follows (e.g., adding a time series of wave resource)

\begin{verbatim}
    int wave_resource_key = 4;
    
    model.add2dRenewableResource(
        "wave",
        "data/input/test/waves_H_s_peak-8m_T_e_peak-15s_1yr_dt-1hr.csv",
        wave_resource_key
    );
\end{verbatim}

\noindent The user must provide a valid (relative) path to resource data, and the data must have the expected format. For examples of the expected format, see the example resource files provided in

\begin{verbatim}
    data/input/test/
\end{verbatim}

\noindent Finally, if the user re-uses the same map key argument in successive calls to this method, then the corresponding contents of the two-dimensional resource maps are overwritten on each call (this will generate a warning).

\subsection{\texttt{addSolar(\;\;)}}

\begin{verbatim}
    void Model :: addSolar(
        structNondispatchable struct_nondisp,
        structSolar struct_solar
    )
\end{verbatim}

This method adds an instance of the \texttt{Solar} class to an existing \texttt{Model} instance. For more info on the \texttt{Solar} class, including the relevant input structures, refer to the chapter on the \texttt{Nondispatchable} class hierarchy. A minimal working example of invoking this method is as follows

\begin{verbatim}
    structNondispatchable nondisp_inputs;
    
    structSolar solar_inputs;
    solar_inputs.resource_key = solar_resource_key;
    
    model.addSolar(nondisp_inputs, solar_inputs);
\end{verbatim}

\noindent Upon invocation, a pointer to the constructed \texttt{Solar} instanced is pushed onto the back of the \texttt{Model} \texttt{nondisp\_ptr\_vec} attribute. So, the order of elements in this attribute is entirely defined by the order in which methods of this type are invoked.

\subsection{\texttt{addTidal(\;\;)}}

\begin{verbatim}
    void Model :: addTidal(
        structNondispatchable struct_nondisp,
        structTidal struct_tidal
    )
\end{verbatim}

This method adds an instance of the \texttt{Tidal} class to an existing \texttt{Model} instance. For more info on the \texttt{Tidal} class, including the relevant input structures, refer to the chapter on the \texttt{Nondispatchable} class hierarchy. A minimal working example of invoking this method is as follows

\begin{verbatim}
    structNondispatchable nondisp_inputs;
    
    structTidal tidal_inputs;
    tidal_inputs.resource_key = tidal_resource_key;
    
    model.addTidal(nondisp_inputs, tidal_inputs);
\end{verbatim}

\noindent Upon invocation, a pointer to the constructed \texttt{Tidal} instanced is pushed onto the back of the \texttt{Model} \texttt{nondisp\_ptr\_vec} attribute. So, the order of elements in this attribute is entirely defined by the order in which methods of this type are invoked.

\subsection{\texttt{addWave(\;\;)}}

\begin{verbatim}
    void Model :: addWave(
        structNondispatchable struct_nondisp,
        structWave struct_wave
    )
\end{verbatim}

This method adds an instance of the \texttt{Wave} class to an existing \texttt{Model} instance. For more info on the \texttt{Wave} class, including the relevant input structures, refer to the chapter on the \texttt{Nondispatchable} class hierarchy. A minimal working example of invoking this method is as follows

\begin{verbatim}
    structNondispatchable nondisp_inputs;
    
    structWave wave_inputs;
    wave_inputs.resource_key = wave_resource_key;
    
    model.addWave(nondisp_inputs, wave_inputs);
\end{verbatim}

\noindent Upon invocation, a pointer to the constructed \texttt{Wave} instanced is pushed onto the back of the \texttt{Model} \texttt{nondisp\_ptr\_vec} attribute. So, the order of elements in this attribute is entirely defined by the order in which methods of this type are invoked.

\subsection{\texttt{addWind(\;\;)}}

\begin{verbatim}
    void Model :: addWind(
        structNondispatchable struct_nondisp,
        structWind struct_wind
    )
\end{verbatim}

This method adds an instance of the \texttt{Wind} class to an existing \texttt{Model} instance. For more info on the \texttt{Wind} class, including the relevant input structures, refer to the chapter on the \texttt{Nondispatchable} class hierarchy. A minimal working example of invoking this method is as follows

\begin{verbatim}
    structNondispatchable nondisp_inputs;
    
    structWind wind_inputs;
    wind_inputs.resource_key = wind_resource_key;
    
    model.addWind(nondisp_inputs, wind_inputs);
\end{verbatim}

\noindent Upon invocation, a pointer to the constructed \texttt{Wind} instanced is pushed onto the back of the \texttt{Model} \texttt{nondisp\_ptr\_vec} attribute. So, the order of elements in this attribute is entirely defined by the order in which methods of this type are invoked.

\subsection{\texttt{addDiesel(\;\;)}}

\begin{verbatim}
    void Model :: addDiesel(
        structDispatchable struct_disp,
        structCombustion struct_combustion,
        structDiesel struct_diesel
    )
\end{verbatim}

This method adds an instance of the \texttt{Diesel} class to an existing \texttt{Model} instance. For more info on the \texttt{Diesel} class, including the relevant input structures, refer to the chapter on the \texttt{Dispatchable} class hierarchy. A minimal working example of invoking this method is as follows

\begin{verbatim}
    structDispatchable disp_inputs;
    
    structCombustion combustion_inputs;
    
    structDiesel diesel_inputs;
    
    model.addDiesel(disp_inputs, combustion_inputs, diesel_inputs);
\end{verbatim}

\noindent Upon invocation, a pointer to the constructed \texttt{Diesel} instanced is pushed onto the back of the \texttt{Model} \texttt{combustion\_ptr\_vec} attribute. So, the order of elements in this attribute is entirely defined by the order in which methods of this type are invoked.

\subsection{\texttt{addLiIon(\;\;)}}

\begin{verbatim}
    void Model :: addLiIon(
        structStorage struct_storage,
        structBatteryStorage struct_battery_storage,
        structLiIon struct_liion
    )
\end{verbatim}

This method adds an instance of the \texttt{LiIon} class to an existing \texttt{Model} instance. For more info on the \texttt{LiIon} class, including the relevant input structures, refer to the chapter on the \texttt{Storage} class hierarchy. A minimal working example of invoking this method is as follows

\begin{verbatim}
    structStorage storage_inputs;
    
    structBatteryStorage batt_storage_inputs;
    
    structLiIon liion_inputs;
    
    model.addLiIon(storage_inputs, batt_storage_inputs, liion_inputs);
\end{verbatim}

\noindent Upon invocation, a pointer to the constructed \texttt{LiIon} instanced is pushed onto the back of the \texttt{Model} \texttt{storage\_ptr\_vec} attribute. So, the order of elements in this attribute is entirely defined by the order in which methods of this type are invoked.

\subsection{\texttt{run(\;\;)}}

\begin{verbatim}
    void Model :: run()
\end{verbatim}

Once the user is finished setting up a \texttt{Model} instance, invoking this method does exactly what one might expect; it runs the energy modelling for this instance. Once the \texttt{run()} method has been invoked, all attributes of the \texttt{Model} instance are populated and ready for use. A minimal working example of invoking this method is as follows

\begin{verbatim}
    model.run();
\end{verbatim}

\subsection{\texttt{writeResults(\;\;)}}

\begin{verbatim}
    void Model :: writeResults(std::string project_name)
\end{verbatim}

This method writes the results of a model run to the disk, and it expects a project name as its sole argument. A minimal working example of invoking this method is as follows

\begin{verbatim}
    model.writeResults("example_project");
\end{verbatim}

\noindent Upon invocation, the attributes of the \texttt{Model} instance, as well as the attributes of any contained \texttt{Nondispatchable}, \texttt{Dispatchable}, and \texttt{Storage} instances, are written to

\begin{verbatim}
    data/output/<project_name>/
\end{verbatim}

\noindent If this directory does not exist at invocation time, then it is created. If this directory already exists at invocation time, then it is overwritten (as in deleted and rebuilt); this will generate a warning.

\subsection{\texttt{clearAssets(\;\;)}}

\begin{verbatim}
    void Model :: clearAssets()
\end{verbatim}

This method clears all \texttt{Nondispatchable}, \texttt{Dispatchable}, and \texttt{Storage} instances from the \texttt{Model} instance. That is to say, invocation clears and resets the following (and only the following) attributes of the \texttt{Model} instance

\begin{enumerate}
    \item \texttt{nondisp\_ptr\_vec}
    \item \texttt{combustion\_ptr\_vec}
    \item \texttt{noncombustion\_ptr\_vec}
    \item \texttt{storage\_ptr\_vec}
\end{enumerate}

\noindent This method is called automatically by the \texttt{Model} class destructor.

\subsection{\texttt{reset(\;\;)}}

\begin{verbatim}
    void Model :: reset()
\end{verbatim}

This method invokes \texttt{clearAssets(\;\;)}, and then resets the following (and only the following) attributes of the \texttt{Model} instance

\begin{enumerate}
    \item \texttt{total\_load\_served\_kWh}
    \item \texttt{total\_fuel\_consumed\_L}
    \item \texttt{total\_CO2\_emitted\_kg}
    \item \texttt{total\_CO\_emitted\_kg}
    \item \texttt{total\_NOx\_emitted\_kg}
    \item \texttt{total\_SOx\_emitted\_kg}
    \item \texttt{total\_CH4\_emitted\_kg}
    \item \texttt{total\_PM\_emitted\_kg}
    \item \texttt{net\_present\_cost}
    \item \texttt{levellized\_cost\_of\_energy\_per\_kWh}
    \item \texttt{net\_load\_vec\_kW}
    \item \texttt{remaining\_load\_vec\_kW}
\end{enumerate}

\noindent The intent of this method is to reset the \texttt{Model} instance for a different set up and \texttt{run()} using the same load and resource data. That way, it avoids having to reconstruct a new \texttt{Model} instance (and hence reload all the load and resource data) every time the user wants to model a new grid design.

\chapter{The \texttt{Nondispatchable} Class Hierarchy}

The \texttt{Nondispatchable} class hierarchy is where the modelling of nondispatchable (as in noncontrollable) production assets, namely renewable production assets, is implemented. The class hierarchy is organized as follows

\begin{verbatim}
    Nondispatchable
        <-- Solar
        <-- Tidal
        <-- Wave
        <-- Wind
\end{verbatim}

\noindent That is, the \texttt{Nondispatchable} class is parent to each of the \texttt{Solar}, \texttt{Tidal}, \texttt{Wave}, and \texttt{Wind} classes. This hierarchy will be expanded and updated as new \texttt{Nondispatchable} assets are added to PGMcpp.\par 
All attributes of the \texttt{Nondispatchable} objects that make up a \texttt{Model} instance will be written to the disk upon invoking \texttt{Model :: writeResults(\;\;)}. However, should you need access to attribute values within your program, you can always get a pointer to the $n^\textrm{th}$ \texttt{Nondispatchable} that was added to the \texttt{Model} by way of

\begin{verbatim}
    Nondispatchable* nondisp_ptr = model.nondisp_ptr_vec[n];
\end{verbatim}

\section{The \texttt{Nondispatchable} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/nondispatchable/Nondispatchable.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/nondispatchable/Nondispatchable.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Nondispatchable} class is the root of its class hierarchy. As such, it is intended to define the attributes and methods common to all members of the hierarchy. Interacting directly with its methods is not intended \textit{under normal execution}; please refer to the header and source files for more information on these methods. That said, this class is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Nondispatchable} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structNondispatchable {
        bool is_sunk = false;
        bool print_flag = false;
        bool test_flag = false;
        
        double cap_kW = 100;
        double replace_running_hrs = 90000;
        
        double nominal_inflation_rate_annual = 0.02;
        double nominal_discount_rate_annual = 0.04;
        
        double capital_cost = -1;
        double op_maint_cost_per_kWh = -1;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structNondispatchable} is described below in Table \ref{tab:structNondispatchable_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structNondispatchable} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{is\_sunk} & {boolean} & {false} & {Defines whether or not the object is modelled as a sunk cost.} \\\hline
        \texttt{print\_flag} & {boolean} & {false} & {Controls whether or not running prints are done.} \\\hline
        \texttt{test\_flag} & {boolean} & {false} & {Toggles testing printouts.} \\\hline
        \texttt{cap\_kW} & {double} & {100} & {Defines the rated power production capacity, expressed in kiloWatts, of the object.} \\\hline
        \texttt{replace\_running\_hours} & {double} & {90000} & {Defines the number of running hours at which a replacement of the object is triggered.} \\\hline
        \texttt{nominal\_inflation\_rate\_annual} & {double} & {0.02} & {Defines the nominal inflation rate (annual), used in computing economic values for the object.} \\\hline
        \texttt{nominal\_discount\_rate\_annual} & {double} & {0.04} & {Defines the nominal discount rate (annual), used in computing economic values for the object.} \\\hline
        \texttt{capital\_cost} & {double} & {-1 (sentinel)} & {Defines the capital cost of the object. The default value of -1 is a sentinel value, which triggers a generic capital cost model within the constructor.} \\\hline
        \texttt{op\_maint\_cost\_per\_kWh} & {double} & {-1 (sentinel)} & {Defines the operation and maintenance costs, per kiloWatt-hour produced, of the object. The default value of -1 is a sentinel value, which triggers a generic operation and maintenance cost model within the constructor.} \\\hline
    \end{tabular}
    }
    \label{tab:structNondispatchable_attributes}
\end{table}

\noindent Additionally, the following enumeration of the \texttt{Nondispatchable} class hierary is defined

\begin{verbatim}
    enum NondispatchableType {
        SOLAR,
        TIDAL,
        WAVE,
        WIND
    };
\end{verbatim}

The complete set of \texttt{Nondispatchable} attributes is described below in Table \ref{tab:Nondispatchable_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Nondispatchable} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{nondisp\_type} & {NondispatchableType} & {SOLAR} & {Defines the \texttt{Nondispathcable} type of the object.} \\\hline
        \texttt{struct\_nondisp} & {structNondispatchable} & {as laid out in Table \ref{tab:structNondispatchable_attributes}} & {The structure of inputs required by the \texttt{Nondispatchable} class constructor.} \\\hline
        \texttt{is\_running} & {boolean} & {false} & {Tracks whether the object is running (i.e., in operation) or not.} \\\hline
        \texttt{n\_timesteps} & {integer} & {0} & {The number of time steps over which the model will run (same as the corresponding \texttt{Model} attribute).} \\\hline
        \texttt{n\_replacements} & {integer} & {0} & {Tracks the number of times the object has been replaced.} \\\hline
        \texttt{project\_life\_yrs} & {double} & {0} & {The project life, in years, to be modelled.} \\\hline
        \texttt{running\_hrs} & {double} & {0} & {Tracks the running hours of the object.} \\\hline
        \texttt{total\_dispatch\_kWh} & {double} & {0} & {Tracks the total energy, expressed in kiloWatt-hours, that has been dispatched by the object.} \\\hline
        \texttt{real\_discount\_rate\_annual} & {double} & {0} & {The real discount rate (annual) to be applied to the object (computed from the given nominal inflation and discount rates).} \\\hline
        \texttt{net\_present\_cost} & {double} & {0} & {The net present cost of the object, as computed following a model run. The units of currency are left undefined.} \\\hline
        \texttt{levellized\_cost\_of\_energy\_per\_kWh} & {double} & {0} & {The levellized cost of energy (per kiloWatt-hour dispatched), as computed following a model run. The units of currency are left undefined.} \\\hline
        \texttt{nondisp\_type\_str} & {string} & {empty} & {A string corresponding to the \texttt{nondisp\_type} attribute.} \\\hline
        \texttt{is\_running\_vec} & {vector of booleans} & {empty} & {A vector which records which time steps the object was running (i.e., in operation) for.} \\\hline
        \texttt{replaced\_vec} & {vector of booleans} & {empty} & {A vector which records replacements of the object.} \\\hline
    \end{tabular}
    }
    \label{tab:Nondispatchable_attributes}
\end{table}

\begin{center}
    \scalebox{0.8}{
    \begin{tabular}{|c|p{0.33\textwidth}|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{production\_vec\_kW} & {vector of doubles} & {empty} & {A vector which records the production, in kiloWatts, of the object over each time step.} \\\hline
        \texttt{dispatch\_vec\_kW} & {vector of doubles} & {empty} & {A vector which records the dispatch, in kiloWatts, of the object over each time step.} \\\hline
        \texttt{curtailment\_vec\_kW} & {vector of doubles} & {empty} & {A vector which records how much excess production (if any), in kiloWatts, is curtailed over each time step.} \\\hline
        \texttt{storage\_vec\_kW} & {vector of doubles} & {empty} & {A vector which records how much excess production (if any), in kiloWatts, is stored over each time step.} \\\hline
        \texttt{real\_capital\_cost\_vec} & {vector of doubles} & {empty} & {A vector which records the real capital costs incurred over each time step. The units of currency are left undefined.} \\\hline
        \texttt{real\_opt\_maint\_cost\_vec} & {vector of doubles} & {empty} & {A vector which records the real operation and maintenance costs incurred over each time step. The units of currency are left undefined.} \\\hline
        \texttt{ptr\_2\_dt\_vec\_hr} & {pointer to vector of doubles} & {NULL} & {A pointer to the \texttt{dt\_vec\_hr} attribute of the \texttt{Model}.} \\\hline
        \texttt{ptr\_2\_time\_vec\_hr} & {pointer to vector of doubles} & {NULL} & {A pointer to the \texttt{time\_vec\_hr} attribute of the \texttt{Model}.} \\\hline
    \end{tabular}
    }
\end{center}

\section{The \texttt{Solar} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/nondispatchable/Solar.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/nondispatchable/Solar.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Solar} class implements the modelling of a solar photovoltaic (PV) array. Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Solar} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structSolar {
        int resource_key = 0;
        
        double derating = 0.8;
        double capital_cost_per_kW = 3000;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structSolar} is described below in Table \ref{tab:structSolar_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structSolar} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{resource\_key} & {integer} & {0} & {The key to the corresponding solar (one-dimensional) resource. This is the key used to index into the \texttt{resource\_map\_1D} attribute of the \texttt{Model}.} \\\hline
        \texttt{derating} & {double} & {0.8} & {This is the derating factor applied to the modelling of production under a given solar resource value.} \\\hline
        \texttt{capital\_cost\_per\_kW} & {double} & {3000} & {This is the model capital cost, per kiloWatt installed capacity, used to compute the capital cost of the object. This value is only used if the generic capital cost model within the \texttt{Nondispatchable} class constructor is triggered.} \\\hline
    \end{tabular}
    }
    \label{tab:structSolar_attributes}
\end{table}

\noindent The sole attribute of the \texttt{Solar} class is the provided \texttt{structSolar} instance. \texttt{Solar} production is modelled using a simple, derated linear model. See the source file for more details.

\section{The \texttt{Tidal} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/nondispatchable/Tidal.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/nondispatchable/Tidal.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Tidal} class implements the modelling of a tidal turbine, or a tidal energy converter (TEC). Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Tidal} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structTidal {
        int resource_key = 0;
        
        TidalPowerCurve power_curve = CUBIC;
        
        double design_speed_ms = 2;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structTidal} is described below in Table \ref{tab:structTidal_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structTidal} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{resource\_key} & {integer} & {0} & {The key to the corresponding tidal (one-dimensional) resource. This is the key used to index into the \texttt{resource\_map\_1D} attribute of the \texttt{Model}.} \\\hline
        \texttt{power\_curve} & {TidalPowerCurve} & {CUBIC} & {Defines which generic power curve to use when modelling production under a given tidal resource value.} \\\hline
        \texttt{design\_speed\_ms} & {double} & {2} & {Defines the design speed, in metres per second, of the turbine. This is used to calibrate the selected generic power curve model.} \\\hline
    \end{tabular}
    }
    \label{tab:structTidal_attributes}
\end{table}

\noindent The sole attribute of the \texttt{Tidal} class is the provided \texttt{structTidal} instance.\par 
The modelling of \texttt{Tidal} production is handled in one of two ways, as enumerated by

\begin{verbatim}
    enum TidalPowerCurve {
        CUBIC,
        EXPONENTIAL
    };
\end{verbatim}

\noindent If \texttt{structTidal :: power\_curve} is CUBIC, then a generic cubic power curve model is employed. If \texttt{structTidal :: power\_curve} is EXPONENTIAL, then a generic exponential power curve model is employed. See the source file for more details.

\section{The \texttt{Wave} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/nondispatchable/Wave.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/nondispatchable/Wave.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Wave} class implements the modelling of a wave energy converter (WEC). Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Wave} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structWave {
        int resource_key = 0;
        
        WavePowerMode power_mode = PARABOLOID;
        
        double design_significant_wave_height_m = 2;
        double design_energy_period_s = 10;
        
        std::string path_2_normalized_performance_matrix = "";
    };
\end{verbatim}

\noindent Each attribute of \texttt{structWave} is described below in Table \ref{tab:structWave_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structWave} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{resource\_key} & {integer} & {0} & {The key to the corresponding wave (two-dimensional) resource. This is the key used to index into the \texttt{resource\_map\_2D} attribute of the \texttt{Model}.} \\\hline
        \texttt{power\_mode} & {WavePowerMode} & {PARABOLOID} & {Defines which approach to use when modelling production under a given wave resource.} \\\hline
        \texttt{design\_significant\_wave\_height\_m} & {double} & {2} & {The design significant wave height, expressed in metres, of the WEC. This is only used if \texttt{power\_mode} = GAUSSIAN.} \\\hline
        \texttt{design\_energy\_period\_s} & {double} & {10} & {The design energy period, expressed in seconds, of the WEC. This is only used if \texttt{power\_mode} = GAUSSIAN.} \\\hline
        \texttt{path\_2\_normalized\_performance\_matrix} & {string} & {empty} & {The (relative) path to the file containing a normalized performance matrix for the WEC. This is only used if \texttt{power\_mode} = NORMALIZED\_PERF...} \\\hline
    \end{tabular}
    }
    \label{tab:structWave_attributes}
\end{table}

\noindent The complete set of \texttt{Wave} attributes is described below in Table \ref{tab:Wave_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Wave} attribute descriptions}
    \scalebox{0.75}{
    \begin{tabular}{|c|p{0.33\textwidth}|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{struct\_wave} & {structWave} & {as laid out in Table \ref{tab:structWave_attributes}} & {The structure of inputs required by the \texttt{Wave} class constructor.} \\\hline
        \texttt{min\_interp\_sig\_wave\_height\_m} & {double} & {0} & {The minimum significant wave height value, in metres, for the purpose of interpolating production. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
        \texttt{max\_interp\_sig\_wave\_height\_m} & {double} & {0} & {The maximum significant wave height value, in metres, for the purpose of interpolating production. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
        \texttt{min\_interp\_energy\_period\_s} & {double} & {0} & {The minimum energy period value, in seconds, for the purpose of interpolating production. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
        \texttt{max\_interp\_energy\_period\_s} & {double} & {0} & {The maximum energy period value, in seconds, for the purpose of interpolating production. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
        \texttt{interp\_sig\_wave\_height\_vec\_m} & {vector of doubles} & {empty} & {A vector of significant wave height values, in metres, for the purpose of interpolating production. Corresponds to the significant wave height values in the given normalized performance matrix. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
        \texttt{interp\_energy\_period\_vec\_s} & {vector of doubles} & {empty} & {A vector of energy period values, in seconds, for the purpose of interpolating production. Corresponds to the energy period values in the given normalized performance matrix. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
        \texttt{interp\_normalized\_performance\_matrix} & {vector of vectors of doubles} & {empty} & {The normalized performance values from the given normalized performance matrix, for the purpose of interpolating production. This is only used if \texttt{structWave :: power\_mode} = NORMALIZED\_PERF...} \\\hline
    \end{tabular}
    }
    \label{tab:Wave_attributes}
\end{table}

\newpage 
The modelling of \texttt{Wave} production is handled in one of three ways, as enumerated by

\begin{verbatim}
    enum WavePowerMode {
        GAUSSIAN,
        NORMALIZED_PERFORMANCE_MATRIX,
        PARABOLOID
    };
\end{verbatim}

\noindent If \texttt{structWave :: power\_mode} is GAUSSIAN, then a generic Gaussian (i.e. bell curve) production model is employed. If \texttt{structWave :: power\_curve} is\\NORMALIZED\_PERFORMANCE\_MATRIX, then production is interpolated (linearly) from the given normalized performance matrix. If \texttt{structWave :: power\_mode} is PARABOLOID, then a generic paraboloid (i.e. quadratic form) production model is employed. See the source file for more details. \par 
Finally, for the NORMALIZED\_PERFORMANCE\_MATRIX case, note that the normalized performance matrix is just that; a matrix of \textit{normalized} performance values for the WEC, with values varying continuously from 0 (no production) to 1 (full, or rated, production). The normalized performance matrix must adhere to the expected format in order for PGMcpp to be able to read it. For an example of the expected format, see

\begin{verbatim}
    data/input/test/normalized_performance_matrix.csv
\end{verbatim}

\section{The \texttt{Wind} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/nondispatchable/Wind.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/nondispatchable/Wind.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Wind} class implements the modelling of a wind turbine. Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Wind} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structWind {
        int resource_key = 0;
        
        double design_speed_ms = 8;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structWind} is described below in Table \ref{tab:structWind_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structWind} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{resource\_key} & {integer} & {0} & {The key to the corresponding wind (one-dimensional) resource. This is the key used to index into the \texttt{resource\_map\_1D} attribute of the \texttt{Model}.} \\\hline
        \texttt{design\_speed\_ms} & {double} & {8} & {Defines the design speed, in metres per second, of the turbine. This is used to calibrate the generic power curve model.} \\\hline
    \end{tabular}
    }
    \label{tab:structWind_attributes}
\end{table}

\noindent The sole attribute of the \texttt{Wind} class is the provided \texttt{structWind} instance. \texttt{Wind} production is modelled using a generic exponential power curve. See the source file for more details.

\chapter{The \texttt{Dispatchable} Class Hierarchy}

The \texttt{Dispatchable} class hierarchy is where the modelling of dispatchable (as in controllable) production assets is implemented. The class hierarchy is organized as follows

\begin{verbatim}
    Dispatchable
        <-- Combustion
            <-- Diesel
\end{verbatim}

\noindent That is, the \texttt{Dispatchable} class is parent to the \texttt{Combustion} class, which in turn is parent to the \texttt{Diesel} class. This hierarchy will be expanded and updated as new \texttt{Dispatchable} assets are added to PGMcpp. \par
All attributes of the \texttt{Dispatchable} objects that make up a \texttt{Model} instance will be written to the disk upon invoking \texttt{Model :: writeResults()}. However, should you need access to attribute values within your program, you can always get a pointer to the $n^\textrm{th}$ \texttt{Dispatchable} that was added to the \texttt{Model} by way of (for example)

\begin{verbatim}
    Dispatchable* disp_ptr = model.combustion_ptr_vec[n];
\end{verbatim}

\section{The \texttt{Dispatchable} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/dispatchable/Dispatchable.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/dispatchable/Dispatchable.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Dispatchable} class is the root of its class hierarchy. As such, it is intended to define the attributes and methods common to all members of the hierarchy. Interacting directly with its methods is not intended \textit{under normal execution}; please refer to the header and source files for more information on these methods. That said, this class is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Dispatchable} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structDispatchable {
        bool is_sunk = false;
        bool print_flag = false;
        bool test_flag = false;
        
        double cap_kW = 100;
        double replace_running_hrs = 30000;
        
        double nominal_inflation_rate_annual = 0.02;
        double nominal_discount_rate_annual = 0.04;
        
        double capital_cost = -1;
        double op_maint_cost_per_kWh = -1;
    };
\end{verbatim}

\noindent Note that this structure is exactly the same as \texttt{structNondispatchable}, so the attribute descriptions laid out in Table \ref{tab:structNondispatchable_attributes} also apply here. Additionally, the following enumeration of the \texttt{Dispatchable} class hierarchy is defined

\begin{verbatim}
    enum DispatchableType {
        DIESEL
    };
\end{verbatim}

\noindent The complete set of \texttt{Dispatchable} attributes is nearly identical to the complete set of \texttt{Nondispatchable} attributes as laid out in Table \ref{tab:Nondispatchable_attributes}. Where the \texttt{Dispatchable} attributes differ is described below in Table \ref{tab:Dispatchable_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Dispatchable} attribute descriptions (where different from, or in addition to, the \texttt{Nondispatchable} attributes)}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{disp\_type} & {DispatchableType} & {DIESEL} & {Defines the \texttt{Dispathcable} type of the object.} \\\hline
        \texttt{struct\_disp} & {structDispatchable} & {as laid out in Table \ref{tab:structNondispatchable_attributes}} & {The structure of inputs required by the \texttt{Dispatchable} class constructor.} \\\hline
        \texttt{n\_starts} & {integer} & {0} & {Tracks the number of times the object was started.} \\\hline
        \texttt{disp\_type\_str} & {string} & {empty} & {A string corresponding to the \texttt{disp\_type} attribute.} \\\hline
    \end{tabular}
    }
    \label{tab:Dispatchable_attributes}
\end{table}

\section{The \texttt{Combustion} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/dispatchable/combustion/Combustion.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/dispatchable/combustion/Combustion.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Combustion} class is the root of its branch of the class hierarchy. As such, it is intended to define the attributes and methods common to all members of the branch. Interacting directly with its methods is not intended \textit{under normal execution}; please refer to the header and source files for more information on these methods. That said, this class is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Combustion} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structCombustion {
        FuelMode fuel_mode = LINEAR;

        double cycle_charging_load_ratio = 0.85;

        double ramp_rate_constraint_kWperhr = -1;   // sentinel
        
        double fuel_cost_L = 1.50;
        double nominal_fuel_escalation_rate_annual = 0.05;

        double linear_fuel_intercept_LkWh = -1; // sentinel
        double linear_fuel_slope_LkWh = -1;     // sentinel
        
        std::string path_2_fuel_consumption_data = "";
        
        double diesel_CO2_kgL = 2.7;
        double diesel_CO_kgL = 0.0178;
        double diesel_NOx_kgL = 0.0014;
        double diesel_SOx_kgL = 0.0042;
        double diesel_CH4_kgL = 0.0007;
        double diesel_PM_kgL = 0.0001;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structCombustion} is described below in Table \ref{tab:structCombustion_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structCombustion} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{fuel\_mode} & {FuelMode} & {LINEAR} & {Defines the approach to be used in modelling fuel consumption.} \\\hline
        \texttt{cycle\_charging\_load\_ratio} & {double} & {0.85} & {Defines the proportion of \texttt{cap\_kW} at which the object produces when running in cycle charging mode.} \\\hline
        \texttt{ramp\_rate\_constraint\_kWperhr} & {double} & {-1 (sentinel)} & {Defines the ramp rate constraint. The default value of -1 is a sentinel value, which triggers a default ramp rate constraint. The default constraint is taken to be that rate which ramps production from zero up to rated capacity in 30 seconds.} \\\hline
        \texttt{fuel\_cost\_L} & {double} & {1.50} & {Defines the price of fuel per unit volume (expressed in litres). The units of currency are left undefined.} \\\hline
        \texttt{nominal\_fuel\_escalation\_rate} & {double} & {0.05} & {Defines the nominal escalation rate in fuel cost (annual), used in computing real fuel costs. This rate is used instead of the given nominal inflation rate.} \\\hline
        \texttt{linear\_fuel\_intercept\_LkWh} & {double} & {-1 (sentinel)} & {Defines the linear fuel intercept, expressed in litres per kiloWatt-hour produced, to be used in modelling fuel consumption. The default value of -1 is a sentinel value, which triggers a generic fuel intercept model within the constructor. This is only used if \texttt{fuel\_mode} = LINEAR.} \\\hline
        \texttt{linear\_fuel\_slope\_LkWh} & {double} & {-1 (sentinel)} & {Defines the linear fuel slope, expressed in litres per kiloWat-hour produced, to be used in modelling fuel consumption. The default value of -1 is a sentinel value, which triggers a generic fuel slope model within the constructor. This is only used if \texttt{fuel\_mode} = LINEAR.} \\\hline
        \texttt{path\_2\_fuel\_consumption\_data} & {string} & {empty} & {Defines the (relative) path to the file containing fuel consumption data. This is only used if \texttt{fuel\_mode} = LOOKUP.} \\\hline
        \texttt{diesel\_*\_kgL} & {double} & {varies; see structure definition} & {Defines the emissions rates for a variety of matter, in kilograms per litre consumed, for diesel fuel.} \\\hline
    \end{tabular}
    }
    \label{tab:structCombustion_attributes}
\end{table}

\noindent The complete set of \texttt{Combustion} attributes is described below in Table \ref{tab:Combustion_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Combustion} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{fuel\_type} & {FuelType} & {FUEL\_DIESEL} & {Defines the type of fuel consumed by the object.} \\\hline
        \texttt{struct\_combustion} & {structCombustion} & {as laid out in Table \ref{tab:structCombustion_attributes}} & {The structure of inputs required by the \texttt{Combustion} class constructor.} \\\hline
        \texttt{real\_fuel\_discount\_rate\_annual} & {double} & {0} & {The real fuel discount rate (annual) to be applied to the object in computing real fuel costs (computed from the given nominal fuel escalation and discount rates).} \\\hline
        \texttt{total\_fuel\_consumed\_L} & {double} & {0} & {Tracks the total fuel consumed, expressed in litres, of the object.} \\\hline
        \texttt{total\_CO2\_emitted\_kg} & {double} & {0} & {Total mass of carbon dioxide, expressed in kilograms, emitted by the object.} \\\hline
        \texttt{total\_CO\_emitted\_kg} & {double} & {0} & {Total mass of carbon monoxide, expressed in kilograms, emitted by the object.} \\\hline
        \texttt{total\_NOx\_emitted\_kg} & {double} & {0} & {Total mass of nitrogen oxides, expressed in kilograms, emitted by the object.} \\\hline
        \texttt{total\_SOx\_emitted\_kg} & {double} & {0} & {Total mass of sulfur oxides, expressed in kilograms, emitted by the object.} \\\hline
        \texttt{total\_CH4\_emitted\_kg} & {double} & {0} & {Total mass of methane, expressed in kilograms, emitted by the object.} \\\hline
        \texttt{total\_PM\_emitted\_kg} & {double} & {0} & {Total mass of particulate matter, expressed in kilograms, emitted by the object.} \\\hline
        \texttt{fuel\_interp\_load\_ratio\_vec} & {vector of doubles} & {empty} & {A vector of load ratios for the purpose of interpolating fuel consumption. This is only used if \texttt{fuel\_mode} = LOOKUP.} \\\hline
        \texttt{fuel\_interp\_consumption\_vec\_Lhr} & {vector of doubles} & {empty} & {A vector of fuel consumption rates, expressed in litres per horus, for the purpose of interpolating fuel consumption. This is only used if \texttt{fuel\_mode} = LOOKUP.} \\\hline
        \texttt{fuel\_vec\_L} & {vector of doubles} & {empty} & {A vector which records the fuel consumed, in litres, by the object over each time step.} \\\hline
        \texttt{real\_fuel\_cost\_vec} & {vector of doubles} & {empty} & {A vector which records the real fuel costs incurred over each time step. The units of currency are left undefined.} \\\hline
    \end{tabular}
    }
    \label{tab:Combustion_attributes}
\end{table}

\begin{center}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{CO2\_vec\_kg} & {vector of doubles} & {empty} & {A vector which records the mass of carbon dioxide emitted, in kilograms, by the object over each time step.} \\\hline
        \texttt{CO\_vec\_kg} & {vector of doubles} & {empty} & {A vector which records the mass of carbon monoxide emitted, in kilograms, by the object over each time step.} \\\hline
        \texttt{NOx\_vec\_kg} & {vector of doubles} & {empty} & {A vector which records the mass of nitrogen oxides emitted, in kilograms, by the object over each time step.} \\\hline
        \texttt{SOx\_vec\_kg} & {vector of doubles} & {empty} & {A vector which records the mass of sulfur oxides emitted, in kilograms, by the object over each time step.} \\\hline
        \texttt{CH4\_vec\_kg} & {vector of doubles} & {empty} & {A vector which records the mass of methane emitted, in kilograms, by the object over each time step.} \\\hline
        \texttt{PM\_vec\_kg} & {vector of doubles} & {empty} & {A vector which records the mass of particulate matter emitted, in kilograms, by the object over each time step.} \\\hline
    \end{tabular}
    }
\end{center}

The modelling of fuel consumption is handled in one of two ways, as enumerated by

\begin{verbatim}
    enum FuelMode {
        LINEAR,
        LOOKUP
    };
\end{verbatim}

\noindent If \texttt{structCombustion :: fuel\_mode} = LINEAR, then a generic linear fuel consumption model is employed. If \texttt{structCombustion :: fuel\_mode} = LOOKUP, then fuel consumption is interpolated (linearly) from the given fuel consumption data. See the source file for more details.\par 
Finally, for the LOOKUP case, note that the fuel consumption data must adhere to the units (i.e. litres per hour) and format expected by PGMcpp in order for it to be readable. For an example of the expected format, see

\begin{verbatim}
    data/input/test/diesel_fuel_curve.csv
\end{verbatim}

\section{The \texttt{Diesel} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/dispatchable/combustion/Diesel.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/dispatchable/combustion/Diesel.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Diesel} class implements the modelling of a diesel generator. Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Diesel} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structDiesel {
        double minimum_load_ratio = 0.2;
        double minimum_runtime_hrs = 5;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structDiesel} is described below in Table \ref{tab:structDiesel_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structDiesel} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{minimum\_load\_ratio} & {double} & {0.2} & {Defines the minimum load ratio (operating constraint) for the object.} \\\hline
        \texttt{minimum\_runtime\_hrs} & {double} & {5} & {Defines the minimum run time (operating constraint), expressed in hours, for the object.} \\\hline
    \end{tabular}
    }
    \label{tab:structDiesel_attributes}
\end{table}

\noindent The complete set of \texttt{Diesel} attributes is described below in Table \ref{tab:Diesel_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Diesel} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{struct\_diesel} & {structDiesel} & {as laid out in Table \ref{tab:structDiesel_attributes}} & {The structure of inputs required by the \texttt{Diesel} class constructor.} \\\hline
        \texttt{time\_since\_last\_start\_hrs} & {double} & {0} & {Tracks the time elapsed, expressed in hours, since the object was last started.} \\\hline
    \end{tabular}
    }
    \label{tab:Diesel_attributes}
\end{table}
 
\chapter{The \texttt{Storage} Class Hierarchy}

The \texttt{Storage} class hierarchy is where the modelling of energy storage assets is implemented. The class hierarchy is organized as follows

\begin{verbatim}
    Storage
        <-- BatteryStorage
            <-- LiIon
\end{verbatim}

\noindent That is, the \texttt{Storage} class is parent to the \texttt{BatteryStorage} class, which in turn is parent to the \texttt{LiIon} class. This hierarchy will be expanded and updated as new \texttt{Storage} assets are added to PGMcpp.\par 
All attributes of the \texttt{Storage} objects that make up a \texttt{Model} instance will be written to the disk upon invoking \texttt{Model :: writeResults(\;\;)}. However, should you need access to attribute values within your program, you can always get a pointer to the $n^\textrm{th}$ \texttt{Storage} that was added to the \texttt{Model} by way of

\begin{verbatim}
    Storage* storage_ptr = model.storage_ptr_vec[n];
\end{verbatim}

\section{The \texttt{Storage} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/storage/Storage.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/storage/Storage.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{Storage} class is the root of its class hierarchy. As such, it is intended to define the attributes and methods common to all members of the hierarchy. Interacting directly with its methods is not intended \textit{under normal execution}; please refer to the header and source files for more information on these methods. That said, this class is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{Storage} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structStorage {
        bool is_sunk = false;
        bool print_flag = false;
        bool test_flag = false;
        
        double cap_kW = 100;
        double cap_kWh = 1000;  // this is "nominal capacity", and is static
        
        double nominal_inflation_rate_annual = 0.02;
        double nominal_discount_rate_annual = 0.04;
        
        double capital_cost = -1;
        double op_maint_cost_per_kWh = -1;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structStorage} is described below in Table \ref{tab:structStorage_attributes} (largely the same as \texttt{structNondispatchable})

\begin{table}[H]
    \centering
    \caption{\texttt{structStorage} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{is\_sunk} & {boolean} & {false} & {Defines whether or not the object is modelled as a sunk cost.} \\\hline
        \texttt{print\_flag} & {boolean} & {false} & {Controls whether or not running prints are done.} \\\hline
        \texttt{test\_flag} & {boolean} & {false} & {Toggles testing printouts.} \\\hline
        \texttt{cap\_kW} & {double} & {100} & {Defines the rated power capacity, expressed in kiloWatts, of the object.} \\\hline
        \texttt{cap\_kWh} & {double} & {1000} & {Defines the rated energy capacity, expressed in kiloWatt-hours, of the object. This attribute is static, and does not vary with object degradation.} \\\hline
        \texttt{nominal\_inflation\_rate\_annual} & {double} & {0.02} & {Defines the nominal inflation rate (annual), used in computing economic values for the object.} \\\hline
        \texttt{nominal\_discount\_rate\_annual} & {double} & {0.04} & {Defines the nominal discount rate (annual), used in computing economic values for the object.} \\\hline
        \texttt{capital\_cost} & {double} & {-1 (sentinel)} & {Defines the capital cost of the object. The default value of -1 is a sentinel value, which triggers a generic capital cost model within the constructor.} \\\hline
        \texttt{op\_maint\_cost\_per\_kWh} & {double} & {-1 (sentinel)} & {Defines the operation and maintenance costs, per kiloWatt-hour produced, of the object. The default value of -1 is a sentinel value, which triggers a generic operation and maintenance cost model within the constructor.} \\\hline
    \end{tabular}
    }
    \label{tab:structStorage_attributes}
\end{table}

\noindent Additionally, the following enumeration of the \texttt{Storage} class hierarchy is defined

\begin{verbatim}
    enum StorageType {
        LIION
    };
\end{verbatim}

The complete set of \texttt{Storage} attributes is described below in Table \ref{tab:Storage_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{Storage} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{storage\_type} & {StorageType} & {LIION} & {Defines the type \texttt{Storage} type of the object.} \\\hline
        \texttt{struct\_storage} & {structStorage} & {as laid out in Table \ref{tab:structStorage_attributes}} & {The structure of inputs required by the \texttt{Storage} class constructor.} \\\hline
        \texttt{n\_timesteps} & {integer} & {0} & {The number of time steps over which the model will run (same as the corresponding \texttt{Model} attribute).} \\\hline
        \texttt{n\_replacements} & {integer} & {0} & {Tracks the number of times the object has been replaced.} \\\hline
        \texttt{cap\_kWh} & {double} & {0} & {Defines the energy capacity, expressed in kiloWatt-hours, of the object. This attribute is dynamic, and does vary with object degradation.} \\\hline
        \texttt{charge\_kWh} & {double} & {0} & {Tracks the charge (i.e., energy content), expressed in kiloWatt-hours, of the object.} \\\hline
        \texttt{min\_charge\_kWh} & {double} & {0} & {Defines the minimum charge (operating constraint), expressed in kiloWatt-hours, of the object.} \\\hline
        \texttt{max\_charge\_kWh} & {double} & {1000} & {Defines the maximum charge (operating constraint), expressed in kiloWatt-hours, of the object.} \\\hline
        \texttt{project\_life\_yrs} & {double} & {0} & {The project life, in years, to be modelled.} \\\hline
        \texttt{total\_throughput\_kWh} & {double} & {0} & {Tracks the total energy, expressed in kiloWatt-hours, that has been transported through the object.} \\\hline
        \texttt{acceptable\_kW} & {double} & {0} & {Holds the charging power, expressed in kiloWatts, that can be accepted by the object at a particular point in time. Is used for memoization.} \\\hline
        \texttt{charging\_kW} & {double} & {0} & {Holds the charging power, expressed in kiloWatts, that is being accepted by the object at a particular point in time. Is used for memoization.} \\\hline
        \texttt{real\_discount\_rate\_annual} & {double} & {0} & {The real discount rate (annual) to be applied to the object (computed from the given nominal inflation and discount rates).} \\\hline
        \texttt{net\_present\_cost} & {double} & {0} & {The net present cost of the object, as computed following a model run. The units of currency are left undefined.} \\\hline
    \end{tabular}
    }
    \label{tab:Storage_attributes}
\end{table}

\begin{center}
    \scalebox{0.8}{
    \begin{tabular}{|c|p{0.33\textwidth}|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{levellized\_cost\_of\_energy\_per\_kWh} & {double} & {0} & {The levellized cost of energy (per kiloWatt-hour throughput), as computed following a model run. The units of currency are left undefined.} \\\hline
        \texttt{storage\_type\_str} & {string} & {empty} & {A string corresponding to the \texttt{storage\_type} attribute.} \\\hline
        \texttt{replaced\_vec} & {vector of booleans} & {empty} & {A vector which records replacements of the object.} \\\hline
        \texttt{charge\_vec\_kWh} & {vector of doubles} & {empty} & {A vector which records the charge (i.e., energy content), expressed in kiloWatt-hours, of the object at each point in time.} \\\hline
        \texttt{charging\_vec\_kW} & {vector of doubles} & {empty} & {A vector which records the charging power (if any), expressed in kiloWatts, that is accepted by the object at each point in time.} \\\hline
        \texttt{discharging\_vec\_kW} & {vector of doubles} & {empty} & {A vector which records the discharging power (if any), expressed in kiloWatts, that is provided by the object at each point in time.} \\\hline
        \texttt{real\_capital\_cost\_vec} & {vector of doubles} & {empty} & {A vector which records the real capital costs incurred over each time step. The units of currency are left undefined.} \\\hline
        \texttt{real\_opt\_maint\_cost\_vec} & {vector of doubles} & {empty} & {A vector which records the real operation and maintenance costs incurred over each time step. The units of currency are left undefined.} \\\hline
        \texttt{ptr\_2\_dt\_vec\_hr} & {pointer to vector of doubles} & {NULL} & {A pointer to the \texttt{dt\_vec\_hr} attribute of the \texttt{Model}.} \\\hline
        \texttt{ptr\_2\_time\_vec\_hr} & {pointer to vector of doubles} & {NULL} & {A pointer to the \texttt{time\_vec\_hr} attribute of the \texttt{Model}.} \\\hline
    \end{tabular}
    }
\end{center}

\section{The \texttt{BatteryStorage} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/storage/batterystorage/BatteryStorage.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/storage/batterystorage/BatteryStorage.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{BatteryStorage} class is the root of its branch of the class hierarchy. As such, it is intended to define the attributes and methods common to all members of the branch. Interacting directly with its methods is not intended \textit{under normal execution}; please refer to the header and source files for more information on these methods. That said, this class is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{BatteryStorage} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structBatteryStorage {
        double init_SOC = 0.5;  // SOC = state of charge
        double min_SOC = 0.4;
        double max_SOC = 0.9;
        
        double hysteresis_SOC = 0.8;
        double reserve_SOC = 0.2;
        
        double charge_efficiency = 0.9;
        double discharge_efficiency = 0.9;
    };
\end{verbatim}

\noindent Each attribute of \texttt{structBatteryStorage} is described below in Table \ref{tab:structBatteryStorage_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{structBatteryStorage} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{init\_SOC} & {double} & {0.5} & {Defines the initial state of charge (SOC) of the object. This is defined as \texttt{Storage :: charge\_kWh} / \texttt{Storage :: structStorage :: cap\_kWh}. This attribute will alter the initial value of \texttt{Storage :: charge\_kWh}.} \\\hline
        \texttt{min\_SOC} & {double} & {0.4} & {Defines the minimum SOC of the object. This attribute will alter the initial value of \texttt{Storage :: min\_charge\_kWh}.} \\\hline
        \texttt{max\_SOC} & {double} & {0.9} & {Defines the maximum SOC of the object. This attribute will alter the initial value of \texttt{Storage :: max\_charge\_kWh}.} \\\hline
        \texttt{hysteresis\_SOC} & {double} & {0.8} & {Defines the SOC that must be attained after reaching the minimum SOC before the object can be discharged again.} \\\hline
        \texttt{reserve\_SOC} & {double} & {0.2} & {Defines a minimum SOC that comes into effect whenever there is otherwise insufficient production and stored energy to meet demand.} \\\hline
        \texttt{charge\_efficiency} & {double} & {0.9} & {Defines how efficiently the object transforms a charging (i.e., input) power into an increase in charge (i.e., energy content).} \\\hline
        \texttt{discharge\_efficiency} & {double} & {0.9} & {Defines how efficiently the object transforms a decrease in charge (i.e., energy content) into a discharging (i.e., output) power.} \\\hline
    \end{tabular}
    }
    \label{tab:structBatteryStorage_attributes}
\end{table}

\noindent The sole attribute of the \texttt{BatteryStorage} class is the provided \texttt{structBatteryStroage} instance. 

\newpage 
\section{The \texttt{LiIon} Class}

\begin{large}
\noindent\underline{Header}:\quad\texttt{header/assets/storage/batterystorage/LiIon.h}\par
\noindent\underline{Source}:\quad\texttt{source/assets/storage/batterystorage/LiIon.cpp}\par
\end{large}
\vspace{5mm}

The \texttt{LiIon} class implements the modelling of a lithium ion (Li-ion) battery energy storage system. Like every class in PGMcpp, it is paired with an input structure which provides the user with the complete bundle of input parameters expected by the \texttt{LiIon} class constructor. This structure is defined as follows

\begin{verbatim}
    struct structLiIon {
        double replace_SOH = 0.8;
        
        double degr_alpha = 10;             // [ ]
        double degr_beta = 1.1;             // [ ]
        double degr_B_hat_cal_0 = 5.222e6;  // [1/sqrt(hr)]
        double degr_r_cal = 0.350;          // [ ]
        double degr_Ea_cal_0 = 5.279e4;     // [J/mol]
        double degr_a_cal = 108.5;          // [J/mol]
        double degr_s_cal = 1.895;          // [ ]
        double gas_constant_JmolK = 8.31446;
        double temperature_K = 273 + 20;    
    };
\end{verbatim}

\noindent The \texttt{replace\_SOH} attribute defines the state of health (SOH) at which the object is considered ``dead" (this is the trigger value for replacing the object within a \texttt{Model} run). The remaining attributes have to do with how the degradation of the object is modelled. For more details, see

\begin{verbatim}
    docs/refs/battery_degradation.pdf
\end{verbatim}

The complete set of \texttt{LiIon} attributes is described below in Table \ref{tab:LiIon_attributes}.

\begin{table}[H]
    \centering
    \caption{\texttt{LiIon} attribute descriptions}
    \scalebox{0.8}{
    \begin{tabular}{|c|c|c|p{0.33\textwidth}|}
        \hline
        \textbf{Attribute} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\\hline\hline
        \texttt{struct\_liion} & {structLiIon} & {as defined above} & {The structure of inputs required by the \texttt{LiIon} class constructor.} \\\hline
        \texttt{SOH} & {double} & {1} & {Tracks the state of health (SOH) of the object. This is defined as \texttt{Storage :: cap\_kWh} / \texttt{Storage :: structStorage :: cap\_kWh}.} \\\hline
        \texttt{SOH\_vec} & {vector of doubles} & {empty} & {A vector which records the SOH of the object at each point in time.} \\\hline
    \end{tabular}
    }
    \label{tab:LiIon_attributes}
\end{table}

\chapter{Dispatch Control}

The control strategy applied to the components of a microgrid can have a significant impact on the economic and environmental performance of the grid design. In light of this, PGMcpp is designed to allow for the modelling of various control strategies. Within the \texttt{Model} class, the following enumeration of dispatch (control) modes is defined

\begin{verbatim}
    enum DispatchMode {
        LOAD_FOLLOWING_IN_ORDER,
        CYCLE_CHARGING_IN_ORDER
    }
\end{verbatim}

\noindent and this control enumeration will be expanded and updated as new dispatch control strategies are added to PGMcpp. Furthermore, given the importance of control, all associated code is stored in \texttt{source/control/}.

\section{Net Load}

Before summarizing the handling (i.e., control) of dispatchable assets, a word on the handling of nondispatchable assets (i.e., the renewable assets) is warranted. Whenever a call is made to \texttt{Model :: run()}, the following sequence of actions is taken

\begin{enumerate}
    \item The net load over the entire modelled project life is computed. (This is where the nondispatchable assets are handled.)
    \item The control of the dispatchable assets is then handled for each point in time. (This is where \texttt{LOAD\_FOLLOWING\_IN\_ORDER} etc. is applied.)
    \item Fuel consumption and emissions are then computed.
    \item Model economics are then computed.
\end{enumerate}

The net load, at any point in time, is here defined as the electrical load minus the sum of all renewable production. That is

\begin{equation}
    \widehat{L}_i = L_i - \sum_{j=1}^N P_{i,\textrm{asset} j}
    \label{eqn:net_load}
\end{equation}

\noindent Where $L_i$ is the $i^\textrm{th}$ load value, $\widehat{L}_i$ is the corresponding net load value, and $P_{i,\textrm{asset} j}$ is the production from the $j^\textrm{th}$ nondispatchable asset at the $i^\textrm{th}$ point in time. Observe that, under this definition, a negative (or zero) net load indicates a surplus of nondispatchable production, and a positive net load indicates a deficit of nondispatchable production.\par 
Finally, note that the production, dispatch, and curtailment of all nondispatchable assets is modelled and recorded, for every point in time, during the handling of action (1) of \texttt{Model :: run()}. As such, the nondispatchable assets \underline{are always used first} at every point in time, regardless of which dispatch control strategy is applied in action (2) of \texttt{Model :: run()}.

\section{Load Following, In Order}

\begin{large}
\noindent\underline{Source}:\quad\texttt{source/control/LOAD\_FOLLOWING\_IN\_ORDER.cpp}\par
\end{large}
\vspace{5mm}

Load following, in order is perhaps the simplest control strategy, and the intent is to meet the load at every point in time using a minimum of production and dispatch. At each point in time, depending on the sign of the net load, dispatch control enters either a charging mode or a discharging mode.\par 
When in charging mode (i.e., $\widehat{L}_i \leq 0$), the following sequence of actions are taken

\begin{enumerate}
    \item Zero production is requested from all dispatchable assets (since they do not need to be producing anything in this case to meet the load). The assets may or may not be able to comply depending on their operating constraints.
    \item All storage assets are charged using any available overproduction. In attempting to charge the storage assets, overproduction from combustion assets is considered first, then non-combustion assets, then nondispatchable assets.
\end{enumerate}

When in discharging mode (i.e., $\widehat{L}_i > 0$), the following sequence of actions are taken

\begin{enumerate}
    \item The set of all storage assets is partitioned into depleted and non-depleted.
    \item All non-depleted storage assets are then used to satisfy as much of the load as possible.
    \item If there is any load left unsatisfied, then all non-combustion assets are used to satisfy as much of the load as possible.
    \item If there is any load left unsatisfied, then all combustion assets are used to satisfy as much of the load as possible.
    \item All depleted storage assets are then charged using any available overproduction. In attempting to charge the storage assets, overproduction from combustion assets is considered first, then non-combustion assets, then nondispatchable assets.
\end{enumerate}

Finally, the ``in order" part of the control algorithm is important. As detailed above, different classes of asset take priority over others when either producing to meet load or sending overproduction to storage. In every case, sending overproduction to storage is always done in the order combustion, then non-combustion, then nondispatchable. Conversely, when in discharging mode, production/dispatch is always storage first, then non-combustion, then combustion. Furthermore, order within each class is also followed, with this order being defined simply by the order in which objects are added to the \texttt{Model}; understanding this offers the user control over asset priority within any given class.

\section{Cycle Charging, In Order}

\begin{large}
\noindent\underline{Source}:\quad\texttt{source/control/CYCLE\_CHARGING\_IN\_ORDER.cpp}\par
\end{large}
\vspace{5mm}

Cycle charging, in order control is largely similar to load following, in order control except for one key difference; whenever there are depleted storage assets, the combustion assets are run at at least some proportion of their capacity in order to charge storage assets more quickly while consuming fuel more efficiently. This ``some proportion" is defined by the \texttt{cycle\_charging\_load\_ratio} attribute of \texttt{structCombustion}. The simple logic here is, if the combustion asset would run at less than this proportion in load following mode, then it will run at this proportion in cycle charging mode (with the exception of zero; if the asset can shut down, then it will still do so). Conversely, if the combustion asset would run at greater than this proportion in load following mode, then it will also do so in cycle charging mode. 

\chapter{An Example PGMcpp Project}

\section{First Time Setup}

\subsection{Linux}

Set up should be fairly straightforward on any Linux distribution.\footnote{PGMcpp was developed and tested in Linux Mint 20.2} Once you have downloaded the PGMcpp files, extract them into a directory of your choice and then issue the command

\begin{verbatim}
    $  make all
\end{verbatim}

\noindent This will build PGMcpp and then run the test suite (see \texttt{test/} for more details). Once you see

\begin{verbatim}
    ************************
    **  ALL TESTS PASSED  **
    ************************
\end{verbatim}

\noindent you are all set up and ready to go.

\subsection{Windows}

In order to use PGMcpp on Windows,\footnote{PGMcpp was tested in Windows 11 Home (10.0.22621 Build 22621).} it is recommended that the user install MSYS2, which is a collection of tools and libraries that provide an easy-to-use environment for building, installing, and running native Windows software. For install instructions, see \url{https://www.msys2.org/} (be sure to follow \textit{all} steps).\par
Once you have worked through the MSYS2 install instructions, there are two more package installations that need to be performed (from within an MSYS2 terminal) in order for PGMcpp to compile; namely

\begin{verbatim}
    $  pacman -Syu
    $  pacman -S base-devel gcc vim cmake
\end{verbatim}

Once the additional packages have been installed, extract the PGMcpp files to somewhere within \texttt{C:\textbackslash msys64\textbackslash home} (assuming you installed MSYS2 to the default location). Then, launch MSYS2 and navigate to the PGMcpp folder by way of (for example)

\begin{verbatim}
    $  cd /home/PGM_cpp_v2-1_dev/
\end{verbatim}

\noindent Finally, issue the command

\begin{verbatim}
    $  make all
\end{verbatim}

\noindent This will build PGMcpp and then run the test suite (see \texttt{test/} for more details). Once you see

\begin{verbatim}
    ************************
    **  ALL TESTS PASSED  **
    ************************
\end{verbatim}

\noindent you are all set up and ready to go.

\section{Example Project Code}

\begin{large}
\noindent\underline{Source}:\quad\texttt{projects/example\_project.cpp}\par
\end{large}
\vspace{5mm}

The example project considers a one year project life at a time resolution of one hour; this is defined by the given electrical load time series data. The project code begins with a minimal instantiation of a \texttt{Model} object.

\begin{verbatim}
    structModel model_inputs;
    model_inputs.path_2_load_data =
        "data/input/test/electrical_load_generic_peak-500kW_1yr_dt-1hr.csv";
    
    Model model(model_inputs);
\end{verbatim}

\noindent Once the \texttt{Model} has been instantiated, renewable resource data for solar, wind, tidal, and wave are loaded.

\newpage
\begin{verbatim}
    //  1. solar
    int solar_resource_key = 1;
     
    model.add1dRenewableResource(
        "solar",
        "data/input/test/solar_GHI_peak-1kWm2_1yr_dt-1hr.csv",
        solar_resource_key
    );
    
    //  2. wind
    int wind_resource_key = 2;
     
    model.add1dRenewableResource(
        "wind",
        "data/input/test/wind_speed_peak-25ms_1yr_dt-1hr.csv",
        wind_resource_key
    );
    
    //  3. tidal
    int tidal_resource_key = 3;
     
    model.add1dRenewableResource(
        "tidal",
        "data/input/test/tidal_speed_peak-3ms_1yr_dt-1hr.csv",
        tidal_resource_key
    );
    
    //  4. wave
    int wave_resource_key = 4;
    
    model.add2dRenewableResource(
        "wave",
        "data/input/test/waves_H_s_peak-8m_T_e_peak-15s_1yr_dt-1hr.csv",
        wave_resource_key
    );
\end{verbatim}

\noindent Then, renewable production assets are added to the \texttt{Model}, one asset per corresponding resource. Again, minimal instantiations are used.

\newpage 
\begin{verbatim}
    //  1. solar
    structNondispatchable nondisp_inputs;
    nondisp_inputs.cap_kW = 150;
    
    structSolar solar_inputs;
    solar_inputs.resource_key = solar_resource_key;
    
    model.addSolar(nondisp_inputs, solar_inputs);
    
    //  2. wind
    nondisp_inputs.cap_kW = 100;
    
    structWind wind_inputs;
    wind_inputs.resource_key = wind_resource_key;
    
    model.addWind(nondisp_inputs, wind_inputs);
    
    //  3. tidal
    nondisp_inputs.cap_kW = 50;
    
    structTidal tidal_inputs;
    tidal_inputs.resource_key = tidal_resource_key;
    
    model.addTidal(nondisp_inputs, tidal_inputs);
    
    //  4. wave
    nondisp_inputs.cap_kW = 50;
    
    structWave wave_inputs;
    wave_inputs.resource_key = wave_resource_key;
    
    model.addWave(nondisp_inputs, wave_inputs);
\end{verbatim}

\noindent Then, a diesel generator is added to the \texttt{Model}. Again, minimal.

\begin{verbatim}
    structDispatchable disp_inputs;
    disp_inputs.cap_kW = 1.2 * 500;
    
    structCombustion combustion_inputs;
    
    structDiesel diesel_inputs;
    
    model.addDiesel(disp_inputs, combustion_inputs, diesel_inputs);
\end{verbatim}

\noindent Then, a lithium-ion battery energy storage system is added to the \texttt{Model}. Again, minimal.

\begin{verbatim}
    structStorage storage_inputs;
    storage_inputs.cap_kW = 150;
    storage_inputs.cap_kWh = 1000;
    
    structBatteryStorage batt_storage_inputs;
    
    structLiIon liion_inputs;
    
    model.addLiIon(storage_inputs, batt_storage_inputs, liion_inputs);
\end{verbatim}

\noindent Finally, the \texttt{Model} is run and the results are written to the disk.

\begin{verbatim}
    //  run model
    model.run();

    
    //  write modelling results to disk
    model.writeResults("example_project");
\end{verbatim}

\noindent The user is, of course, encouraged to use the provided example project as a template for all future projects.

\section{Compiling and Executing}

To compile and execute the example project (or in fact, any project), simply issue the command

\begin{verbatim}
    $  make project
\end{verbatim}

\noindent For compiling and executing some other project, say \texttt{my\_project.cpp} for example, one need only make a single change to the provided makefile. Namely, the \texttt{PROJECT\_NAME} variable need only be changed from \texttt{example\_project} to \texttt{my\_project}. Note that this works on the assumption that \texttt{my\_project.cpp} exists and is located within \texttt{projects/}.

\section{Expected Output}

Upon successfully compiling and executing the example project, you should see

\begin{verbatim}
    Results successfully written to data/output/example_project/
\end{verbatim}

\noindent Within \texttt{data/output/example\_project/}, you should find the following file structure

\begin{verbatim}
    data/output/example_project/
        Combustion/
        Model/
        Nondispatchable/
        Storage/
\end{verbatim}

\subsection{\texttt{Combustion/}}

The \texttt{Combustion/} folder contains the results for each \texttt{Combustion} object that was added to the \texttt{Model} prior to being run. In this case, there is only one set of results; namely \texttt{600kW\_DIESEL\_0}, the results for the 600 kW diesel generator. Within this results folder, you will find two files

\begin{enumerate}
    \item \texttt{600kW\_DIESEL\_0\_results.csv}: a complete time series of the diesel generator dynamics over the course of the modelled project life; and,
    \item \texttt{600kW\_DIESEL\_0\_summary.txt}: a summary of the aggregate model results for the diesel generator, including key economic and environmental metrics.
\end{enumerate}

\subsection{\texttt{Model/}}

The \texttt{Model/} folder contains the model-level results from the model run. Within this folder, you will find three files

\begin{enumerate}
    \item \texttt{Model\_dispatch\_results.csv}: a complete time series of the load in parallel with the dispatch time series for every object added to the \texttt{Model} prior to being run;
    \item \texttt{Model\_load\_results.csv}: a complete time series of the load, net load, and remaining load; and,
    \item \texttt{Model\_summary.txt}: a summary of the aggregate model-level results, including key economic and environmental metrics.
\end{enumerate}

\subsection{\texttt{Nondispatchable/}}

The \texttt{Nondispatchable/} folder contains the results for each \texttt{Nondispatchable} (i.e., renewable) object that was added to the \texttt{Model} prior to being run. In this case, there are four sets of results; namely

\begin{enumerate}
    \item \texttt{50kW\_TIDAL\_2}: the results for the 50 kW tidal turbine;
    \item \texttt{50kW\_WAVE\_3}: the results for the 50 kW wave energy converter;
    \item \texttt{100kW\_WIND\_1}: the results for the 100 kW wind turbine; and,
    \item \texttt{150kW\_SOLAR\_0}: the results for the 150 kW solar photovoltaic array.
\end{enumerate}

\noindent Note that the trailing integer in the folder names is simply the index of the object within \texttt{Model :: nondisp\_ptr\_vec}; that is, it simply indicates the order in which the objects were added to the \texttt{Model}.\par 
Within each object results folder, you will find two files

\begin{enumerate}
    \item \texttt{*\_results.csv}: a complete time series of the object dynamics over the course of the modelled project life; and,
    \item \texttt{*\_summary.txt}: a summary of the aggregate model results for the object, including key economic and environmental metrics.
\end{enumerate}

\subsection{\texttt{Storage/}}

The \texttt{Storage/} folder contains the results for each \texttt{Storage} object that was added to the \texttt{Model} prior to being run. In this case, there is only one set of results; namely \texttt{150kW\_1000kWh\_LIION\_0}, the results for the 150 kW, 1000 kWh lithium-ion battery energy storage system. Within this results folder, you will find two files

\begin{enumerate}
    \item \texttt{150kW\_1000kWh\_LIION\_0\_results.csv}: a complete time series of the lithium-ion battery energy storage system dynamics over the course of the modelled project life; and,
    \item \texttt{150kW\_1000kWh\_LIION\_0\_summary.txt}: a summary of aggregate model results for the lithium-ion battery energy storage system, including key economic and environmental metrics.
\end{enumerate}

\section{More Example Code}

More examples of how to interact with a \texttt{Model} object can also be found in\\\texttt{test/test\_Model.cpp}.

% ----- REFERENCES -----

%\newpage
%\addcontentsline{toc}{chapter}{References}
%\bibliography{refs.bib}{}
%\bibliographystyle{IEEEtran} 
%\bibliographystyle{apalike} 


% ---- APPENDICES ----

%\appendix
%\chapter{Supporting Tables}
%\pagenumbering{arabic}
%\renewcommand*{\thepage}{A-\arabic{page}}

%[...]

\end{document}
